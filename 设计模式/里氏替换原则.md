## 里氏替换原则
### 定义
> “只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。”
 
### 作用
**用于约束子类对父类方法的扩展**
继承对于面向对象的语言设计有着举足轻重的意义，但同时也有着不可忽视的痛（缺陷）。优点如下：
- 代码共享，子类拥有父类方法与属性。
- 提高代码的重用性
- 子类可以形似父类，但又异于父类
- 提高了扩展性
- 提高产品或项目的开放性
与之相对的缺陷：
- 继承是侵入性的
- 降低了代码的灵活性，子类拥有父类的属性和方法，使其多了一些约束
- 增强了耦合性
基于以上缺陷，我们有了*里氏替换原则*这一设计规范，为什么是设计规范呢？所谓了设计规范就是基于经验的一种良好的实践，不是语法上的限制。

### 原则
#### 子类必须完全实现父类的方法
一般我们设计父类的时候我们会将父类设计为抽象类，这样设计是遵循了面向接口设计的，同时也具备一定的灵活性，这样子类继承父类时就必须实现父类的全部抽象方法，当然这里子类也一定不是抽象类，当然这一点是我们在设计上的一点点技巧。
#### 子类可以有自己的个性
子类继承父类当然不能只具备父类能力，如果这样的话继承也就没有啥意义了，所以子类在实现父类方式时可以根据子类本身特性来实现其功能。
#### 覆盖或实现父类的方法时输入参数可以被放大
解释一下这里放大是指入参范围的扩大，如下例子：
```java
public class LSPClass {
    public static void main (String[] args){
        Son f = new Son();
        f.doSomething(new HashMap());
    }
}
class Father{
    public Collection doSomething(HashMap map){
        System.out.print("Father method executed.");
        return map.values();
    }
}
class Son extends Father{
    public Collection doSomething(Map hMap) {
        System.out.print("SubClass method executed.");
        return hMap.values();
    }
}
```
子类在继承父类重载`doSomething`方法时，扩大了接受参数的范围，这一点是遵循了里氏替换原则的，我在使用时可以用子类对象来替代父类对象。
#### 覆写或实现父类的方法时输出结果可以被缩小
这里的缩小是指返回的结果对象是相同类型或者是其类型的子类对象。